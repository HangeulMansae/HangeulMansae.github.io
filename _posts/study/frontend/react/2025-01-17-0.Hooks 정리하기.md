---
layout: post
title: 00. Hooks 정리하기
categories: [study, frontend, react]
tags: [blog]
---

- toc
{:toc .large-only}

## Hooks이란
클래스형 컴포넌트가 아닌 함수형 컴포넌트에서도 상태 관리 등 생명주기와 관련된 작업을 할 수 있게 해주는 기능이다.     
종류로는 

## useState
가장 기본적인 Hook으로, 함수 컴포넌트 내에서도 **`가변적인 상태`**를 가질 수 있게 해준다.     
만약 버튼을 눌렀을 때 숫자가 변해야 한다면, 숫자 값을 가지는 상태가 필요할 것이고,     
증가 버튼을 눌렀을 때는 숫자가 늘어나며, 감소 버튼을 눌렀을 때는 숫자가 감소해야 할 것이다.

예를 들자면
~~~js
// file: "UseStateExample.js"
import {useState} from "react"

const UseStateExample = () => {
  /**
   * 초기 값을 0으로 가지는, 상태 생성
   * useState(초기값)을 호출하면, 초기값이 있는 상태와, 상태를 변경하는 함수를 return한다
   * 즉 값은 num으로 들어가고 setNum은 이러한 num 값을 바꿀 때 사용하는 함수이다.
   */
  const [num, setNum] = useState(0);
  return (
    <div>
      <p>현재 num 값은 {num}</p>
      {/*
        버튼을 눌렀을 때 setNum이 호출되도록 하는 함수를 만든다.
      */}
      <button onClick={() => setNum(before => before + 1)}>숫자 1 증가</button>
      <button onClick={() => setNum(before => before - 1)}>숫자 1 감소</button>
    </div>
    
  )
  
}

export default UseStateExample;
~~~

이런 식으로 작성하여, 버튼을 눌렀을 때 setNum이 실행되는 함수를 호출하여, num이라는 state가 바뀌도록 한다.

onClick에는 **실행시킬 함수를** 넣어줘야 한다.     
onClick={setNum(before => before + 1)}     
위와 같은 코드는 setNum의 실행 결과를 onClick으로 준 것이지 함수를 넘겨준 것이 아님을 주의하자.
{:.faded}
{:.note title="Note"}

## useEffect
컴포넌트가 렌더링될 때마다 특정 작업을 수행하도록 한다.

~~~js
// file: "UseEffectExample.js"
import {useState, useEffect} from "react"

const UseEffectExample = () => {
  /**
   * useEffect는 렌더링 등 조건이 맞았을 때 실행할 함수와, 의존성 배열을 인자로 받는다.
   * 그리고 의존성 배열의 존재 유무와, 값에 따라 조금씩 실행 조건이 달라지게된다.
   * 
   * 첫번째로 만약 의존성 배열을 아예 설정하지 않았다면, 모든 렌더링과 리렌더링 과정마다 실행된다.
   * 두번째로 만약 빈 의존성 배열을 넣었다면, 맨 최초에 렌더링 될 때 1회만 실행된다.
   * 세번째로 만약 의존성 배열을 넣었다면, 최초 렌더링 될 때와 해당 의존성이 변경되어 리렌더링이 동작할 때 실행된다.
   * 세번째에서 중요한 것은 단순히 리렌더링이 되면 동작하는 것이 아니라 의존성으로 넣었던 것이 변경되어 리렌더링이 동작할 때 작동하는 것이다.
   */
  const [message, setMessage] = useState('초기 메세지입니다.');
  const [junk, setJunk] = useState('필요없는 상태입니다.');

  useEffect(() => {console.log("의존성 배열 자체를 전달하지 않았습니다.")});
  useEffect(() => {console.log("빈 의존성 배열을 전달했습니다.")}, []);
  useEffect(() => {console.log("의존성 배열을 전달했습니다")}, [message]);

  return (
    <div>
      <p>{message}</p>
      <p>{junk}</p>
      <div>
        <button onClick={() => {setMessage("메세지를 변경했습니다!")}}>useEffect의 의존 배열로 설정한 메세지를 변경하는 버튼입니다.</button>
        <button onClick={() => {setJunk("필요 없는 상태를 변경했습니다!")}}>의존성으로 넣어주지 않은 상태를 변경하는 버튼입니다.</button>
      </div>
    </div> 
  )
}

export default UseEffectExample;
~~~

+ ### UseEffect 초기 화면 실행 시
  ![최초 렌더링 시](/assets/img/study/frontend/react/Hooks%20정리하기/UseEffect%20초기%20실행%20시.jpg){: loading="lazy"}
  초기 렌더링 시에는 의존성 배열 설정 유무와 상관 없이 모든 useEffect의 함수가 실행된다.
  {:.figcaption} 

+ ### 의존성과 관련 없는 상태 변경으로 인한 리렌더링 시
  ![의존성과 관련 없는 상태 변경으로 인한 리렌더링 시](/assets/img/study/frontend/react/Hooks%20정리하기/UseEffect%20의존성과%20관련%20없는%20변경으로%20인한%20리렌더링%20시.jpg){: loading="lazy"}
  의존성으로 설정한 것과 관련 없는 상태로 인한 리렌더링 시에는 의존성 배열 자체를 넘겨주지 않은 useEffect의 함수만 실행된다.     
  즉 의존성 배열 자체가 비어 있는 useEffect와 변경된 상태와 의존성이 없는 useEffect는 실행되지 않는 것을 볼 수 있다.
  {:.figcaption} 
  
+ ### 의존성으로 설정한 상태 변경으로 인한 리렌더링 시
+ ![의존성으로 설정한 상태 변경으로 인한 리렌더링 시](/assets/img/study/frontend/react/Hooks%20정리하기/UseEffect%20의존성으로%20설정한%20상태%20변경으로%20인한%20리렌더링%20시.jpg){: loading="lazy"}
  의존성으로 설정한 것 상태로 인한 리렌더링 시에는 해당 상태에 의존되거나, 의존성 배열 자체를 넘겨주지 않은 useEffect의 함수만 실행된다.     
  즉 의존성 배열 자체가 비어 있는 useEffect는 실행되지 않는 것을 볼 수 있다.
  {:.figcaption}


## UseReducer
UseState로도 상태를 관리할 수 있지만, 다양한 이벤트 등에서 상태를 변경하는 작업이 있거나, 변경이 복잡할 경우     
상태의 변화를 파악하기 위해서는 각 이벤트들을 전부 확인해야 하고, 코드가 길어지면 지저분해지는 문제가 있다.     

이를 useReducer를 이용하여, 변경 관련 내용을 reducer에 작성하고, 각 이벤트에서는 업데이트 함수를 호출해주기만 하면 되므로,     
상태가 어떻게 변하는지에 대한 파악이 용이하고 여러 곳에서 state 수정이 생기더라도 수정 관련 코드를 작성하지 않아도 되기 때문에, 코드가 간결해진다.

~~~js
// file: "UseReducerExample.js"
import {useState, useEffect, useReducer} from "react"

const UseReducerExample = () => {
/**
 * useReducer는 state가 어떻게 업데이트 되어야 할 지 정의가 되어 있는지를 정의한 Reducer 함수와, 초기 state 값을 인자로 받아서,
 * 현재 state와 state를 새로운 값으로 업데이트 시키는 함수를 반환한다.
 * 
 * 이 때 업데이트 시키는 함수에는 오직 한 개의 인자만이 들어올 수 있다.
 * 
 * Reducer 함수는 반드시 현재 state, 업데이트 함수에 들어온 인자를 요구하는 함수로 작성해야 하며, 최종적으로 변경시킬 값을 return 하는 식이여야 한다.
 * 본 코드는 UseStateExample에서 useState 대신 useReducer를 이용하여 작성한 것이다.
*/

// 상태를 어떻게 업데이트 할 지 정의한 reducer 함수
const reducer = (state, action) => {
    switch(action){
      case 'Increase':
        return state+1
      case 'Decrease':
        return state-1
      default:
        return 0
    }
  }

  // reducer 함수를 useReducer의 첫번째로, 초기화 인자를 2번째 값으로 넘겨주면 현재 state와 업데이트를 호출하는 dispatch 함수가 반환된다.
  const [num, dispatch] = useReducer(reducer, 0)
  return (
    <div>
      <p>현재 num 값은 {num}</p>
      {/* 이렇게 dispatch를 호출할 때 안에 인자를 넣으면 reducer의 2번째 인자로 값이 들어온다.*/}
      <button onClick={() => dispatch('Increase')}>숫자 1 증가</button>
      <button onClick={() => dispatch('Decrease')}>숫자 1 감소</button>
    </div>
  )
}

export default UseReducerExample;
~~~

다만 만약 초기화를 할 때 함수를 호출하여서 해야 한다면, 2 번째 인자에 넣는 것은 고려해봐야 할 부분이다.     

~~~js
// file: "UseReducerOptimization.js"
function createInitialState(username) {
  const initialTodos = [];
  for (let i = 0; i < 50; i++) {
    initialTodos.push(
      username + (i + 1)
    );
  }
  return initialTodos;
}

const [optimizer, opt] = useReducer(reducer, createInitialState("a"))
~~~

만약 위와 같은 방식으로 초기화를 진행하게 된다면, 매 렌더링 시마다 createInitialState가 호출되기 때문이다.

물론 초기 렌더링 시에만 createInitialState 함수를 실행한 값이 반영이 되겠지만,     
이 값을 단순히 초기화에 사용될 값으로만 인식하고, 초기 렌더링 시에만 평가해야 한다라고 인식하지는 않기 때문에,     
매 렌더링 시마다 두 번째 인자로 제공된 것을 렌더링 시마다 평가한다.

그래서 2 번째 인자로 함수의 결과를 넘겨주게 되면 매 렌더링 시마다 해당 함수를 호출하는 불필요한 낭비가 발생하고,     
이를 막기 위해서는 초기화 함수를 3 번째 인자로 넘겨주는 것이다.

useReducer는 인자로 Reducer 함수, 초기 값, 초기화 함수 이렇게 3가지를 받는다.
{:.faded}
{:.note title="Note"}

따라서 위 코드를 아래와 같이 바꾼다면 함수가 매번 호출되지 않고, 초기 렌더링 시에만 호출되어 불필요한 호출을 줄일 수 있다.

~~~js
// file: "UseReducerOptimization.js"
function createInitialState(username) {
  const initialTodos = [];
  for (let i = 0; i < 50; i++) {
    initialTodos.push(
      username + (i + 1)
    );
  }
  return initialTodos;
}

/* 
  이렇게 호출하면 createInitalState의 인자로 "a"가 들어가서 실행된 값이 초기 값으로 결정되고,
  초기 렌더링 이후 렌더링이 발생하더라도 다시 호출되지는 않는다.
*/
const [optimizer, opt] = useReducer(reducer, "a", createInitialState)
~~~