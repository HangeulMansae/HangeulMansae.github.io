---
layout: post
title: 08.  Process 실행과 관련된 자료구조, Process 상태, Switch, Kernel
sitemap: false
categories: [study, cs, os]
tags: [blog]
---

- toc
{:toc .large-only}

## Process

- ### 정의

  - 실행 가능한 Program이 Memory에 올라와서 실행시킬 수 있는 것

  - 실행 시퀀스이자 Active Entity

  - 현재 상태(Program + stack)와 자원을 얼마나 사용하고 있는지, 명령을 실행하고 관리하는 Activity의 단위

- ### 기본 구성 요소
  - Program Code
  - 코드와 연관된 Data 집합
- ### 특성
  - 실행 단위 ( Thread, Light Weight Process )
  - 자원 소유권 단위 ( Process, Task )

## Program

Disk에 Text와 Data가 저장되어 있는 이진 시퀀스이자 Passive Entity

Program이 실행될 때 비로소 Process

**하나의 Program은 여러 개의 Process가 될 수 있음**

**(여러 User들이 같은 Program을 실행할 때)**

## Stack

프로그램을 실행시키면 Return Address를 Stack에 Push하고 종료되면 Pop 함

프로그램의 Excution Sequence를 관리하기 위함

**Stack의 Top을 관리하기 위한 StakPointer가 존재**

**보호하기 위해 base와 limit 레지스터 존재**

Stack은 높은 주소에서 낮은 주소로 자람

=> base의 주소가 limit 보다 높음

Process를 실행시키기 위해선 반드시 Stack 필요

- ### Stack Frame

  아래의 정보들을 모아서 Stack Frame이라고 함

  - Return Address
  - Parameter
  - Return Parameter

- ### Call Stack
  Stack Frame들의 집합

  그때 당시의 Stack Frame을 보여줌

## Program Description

- ### User Level Context (memory context)

  프로그램을 수행하기 위한 기본적인 구성요소

  - #### 구성요소
    - User text
    - User data
    - User Stack

- ### System Level Context
  - #### 구성요소
    Process Control Block
  - #### Process Control Block
    OS가 Process를 관리하기 위한 정보들의 집합
    - #### 구성요소
      - ##### Process Identification
        식별자 정보

        PID, UID 등

      - Process Control Information
        Process 간 Relation 정보(부모, 자식, 형제), 등
      - ProcessorState Information
        Process가 현재 어떤 상태인지, Priority 등
- ### Hardware Context (register)
  PC, PSW 등 레지스터의 Content

## Process Control Block

OS에서 가장 중요한 Data Sturcture

**OS가 Process 관리하기 위해 필요한 모든 정보를 저장 관리하는 Structure**

Multiprocessing을 가능하게 하며 각각의 Process가 각각의 PCB를 가짐

- #### 구성요소

  - ##### Process Identification
    식별자 정보

    PID, UID 등
  - ##### Process Control Information

    Process 간 Relation 정보

    - Process간 관계 (부모 자식)
    - Process 상태 (Run, Ready, Block)
    - 메모리 정보 (Segment, Page)

  - ##### Processor State Information
    Processor의 레지스터 정보

    Register와 Priority 등 정보
    - User level Register
    - Control and State Register

## Process Image

Process Image란 OS가 어떤 Process를 관리하고 제어하기 위해 알아야 할 정보들의 집합

OS가 관리하는 각 Process별 Description

Process가 어디에 위치해 있는지, Process를 관리하기 위한 속성들에 대한 정보

**User Level Context + PCB**

Process의 식별 정보, 상태 정보 뿐만 아니라 해당 Process의

- ### 구성 요소
  - User Text
  - User Data
  - Stack
  - PCB
  - Kernel Stack

## Process State Model

Process의 상태가 변화되는 과정을 모델화 한 것

- ### Two State Process Model

  - #### 상태 종류
    - ##### Not Running
      Queue에서 대기 중인 상태
    - ##### Running
      Dispatcher에 의해 선택되어 CPU에서 Running 중인 상태
  - #### 과정

  1.  Process가 Queue에 적재됨

  2.  Queue에 들어있는 Process 중 하나를 Dispatcher가 Scheduiling 기법에 따라서 골라서 Processor에서 수행 => Running 상태

  3.  만약 끝나면 그대로 Exit

  4.  Time Slicing을 다 사용하면 Pause 되어 다시 Queue로 돌아감 => Not Running 상태

  - #### 문제점
    사용자로부터 Input 입력 등 IO Request가 필요할 때 Event가 올 때까지 대기해야 하기 때문에 IO 입력 대기 중인 Process를 다시 Running 상태로 올리는 비효율적인 문제 존재

- ### Five State Process Model
  Not Running 상태를 Ready와 Blocked로 세부화함
  - #### 상태 종류
    - ##### New
      프로세스 생성
    - ##### Ready
    - ##### Running
    - ##### Blocked
      프로세스가 I/O관련 작업을 처리할 때 전환되는 상태

      I/O 작업이 끝나면 다시 Ready 상태로 돌아가 선택되길 기다림
      **Time out은 여기로 안옴**
    - ##### Exit
- ### Seven State Process Model

  메모리의 공간이 부족해지면 Process를 잠시 Disk로 옮겨야 함 => Suspend

  => 우선순위에 따라 Blocked 상태의 Process를 옮길 수도, Ready 상태의 Process를 옮길 수도 있음, 심지어 Running 상태에 있던 것도 Suspend될 수 있음

  => Five State Process Model에서 Ready Suspended, Block Suspended 상태가 추가됨

  - #### 상태 종류
    - ##### New
    - ##### Ready
    - ##### Running
    - ##### Blocked
      Running 중 I/O 작업 발생했을 때 전환되는 상태

      Event가 발생하면 다시 Ready 상태로 전환됨
    - ##### Blocked Suspend
      Block 상태에서 Suspend 된 상태

      다시 공간이 생겨 Activate 될 때 Blocked 상태로 전환

      만약 Suspend된 상태에서 Event가 발생하면 Ready Suspend 상태로 전환
    - ##### Ready Suspend
      New or Ready or Running 상태에서 공간 부족으로 Suspend된 상태

      다시 공간이 생겨 Activate 될 때 Ready 상태로 전환
    - ##### Exit

## Swapping

프로세스를 Main memory에서 Disk로 옮기는 것

OS에서 낮은 우선순위의 Process를 우선적으로 Swapping해서 Suspended queue에 적재

## Process List Structures

PCB에서는 각 Process의 정보를 가지고 있고, 이 Process들의 상태 별로 PCB들을 리스트처럼 관리하는 구조

## Mode Switch

User Mode에서 Kernel Mode, Kernel Mode에서 User Mode로 Mode를 전환하는 것

**Process는 바뀌는 것 X**

## Process Switch

Process가 다른 것으로 바뀌는 것

- 과정
  1.  Current Process의 Processor의 context(**pc, sp, psw** )를 저장
  2.  Current Process의 PCB를 Update (Ready, Blocked 등)
  3.  Current Process의 PCB를 적절한 Queue로 이동
  4.  다음으로 실행시킬 Process를 결정
  5.  결정한 Process의 PCB를 Update (Running 상태로)
  6.  TLB를 Update
  7.  Process의 Processor의 context를 복원

**Process Switch가 Mode Switch가 훨씬 Cost가 높음**

## Kernel Model 종류 (OS 실행 모델)

- ### Nonprocess Kernel
  전통적인 방식

  Kernel이 분리된 Entity로서 실행됨

  => User Process에서 Kernel로 들어가는 것이 Process Switch와 대등
- ### Execution within User Processes (Common in OS)

  User Processes 내부에서 커널 작동

  Kernerl 내에서 실행되는 함수들의 Execution Sequence를 관리하기 위한 Kernel Stack이 필요

  각 Process Image가 Kernel Stack도 포함함

  => Timer등 간단한 작업을 위해 Kernel로 들어가는 것은 Process 내 Kernel에서 처리하고 이는 Mode Switch에 해당

- ### Process-Based Operating System (Modular OS)

  Kernel을 아주 핵심적인 Code로 구성하고, 나머지 Kernel 기능들을 User Process Level로 올려서 마치 사용자들이 Module처럼 유연한 설계가 가능한 OS Kernel 방식

  Non Critical한 OS Function을 Process Level로 분리

## Kernel Stack

하나의 Process에는 일반 Stack과 Kernel에서 Kernel 함수를 수행하기 위한 Kernel Stack으로 2가지의 Stack이 존재

- ### 장점
  - 자원을 보호할 수 있음 (user stack이 더렵혀졌을 때도 Kernel을 실행시킬 수 있음)